import { ResultAsync } from 'neverthrow'
import { typedError } from '../../../helpers/typed-error'
import type { SealedBoxProps } from './helpers/sealbox'
import { Buffer } from 'buffer'

export type EncryptionModule = ReturnType<typeof EncryptionModule>
export const EncryptionModule = () => {
  const cryptoDecrypt = (data: Buffer, encryptionKey: CryptoKey, iv: Buffer) =>
    ResultAsync.fromPromise(
      crypto.subtle.decrypt({ name: 'AES-GCM', iv }, encryptionKey, data),
      typedError,
    ).map(Buffer.from)

  const cryptoEncrypt = (data: Buffer, encryptionKey: CryptoKey, iv: Buffer) =>
    ResultAsync.fromPromise(
      crypto.subtle.encrypt(
        {
          name: 'AES-GCM',
          iv,
        },
        encryptionKey,
        data,
      ),
      typedError,
    ).map(Buffer.from)

  const getKey = (encryptionKey: Buffer) =>
    ResultAsync.fromPromise(
      crypto.subtle.importKey(
        'raw',
        encryptionKey,
        {
          name: 'AES-GCM',
          length: 256,
        },
        false,
        ['encrypt', 'decrypt'],
      ),
      typedError,
    )

  /**
   * Decrypts data using AES-GCM algorithm
   *
   * @param {Buffer} data - payload to be decrypted
   * @param {Buffer} encryptionKey - key used for decryption
   * @param {Buffer} iv - initialization vector used when data was encrypted
   * @returns decrypted data wrapped inside ResultAsync
   */
  const decrypt = (
    data: Buffer,
    encryptionKey: Buffer,
    iv: Buffer,
  ): ResultAsync<Buffer, Error> =>
    getKey(encryptionKey).andThen((cryptoKey) =>
      cryptoDecrypt(data, cryptoKey, iv),
    )

  /**
   * Encrypts data using AES-GCM algorithm
   *
   * @param {Buffer} data - payload to be encrypted
   * @param {Buffer} encryptionKey - key used for encryption
   * @param {Buffer} iv - optional initialization vector
   * @returns encrypted data wrapped inside ResultAsync
   */
  const encrypt = (
    data: Buffer,
    encryptionKey: Buffer,
    iv = createIV(),
  ): ResultAsync<
    Omit<SealedBoxProps, 'ciphertextAndAuthTag' | 'authTag'>,
    Error
  > =>
    getKey(encryptionKey)
      .andThen((cryptoKey) => cryptoEncrypt(data, cryptoKey, iv))
      .map((ciphertext) => ({
        combined: Buffer.concat([iv, ciphertext]),
        iv,
        ciphertext,
      }))

  /**
   * Creates 96 bits (12 bytes) initialization vector for AES-GCM encryption
   * @returns {Buffer} 12 randomly generated bytes
   */
  const createIV = () => Buffer.from(crypto.getRandomValues(new Uint8Array(12)))

  return { encrypt, decrypt, createIV }
}
